<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>STUDYSYNC</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; line-height: 1.7; padding: 24px; }
    h1 { margin-bottom: 12px; }
    .controls { display: none; } /* 버튼 영역 제거 */

    /* 데스크톱 기본: 기존 배치 유지(왼쪽 120px, 오른쪽 32px) */
    #output {
      padding: 16px; border-radius: 12px; background: #f8fafc; font-size: 1.15rem;
      min-height: 80px;

      margin-left: 120px;          /* 왼쪽 여백 */
      margin-right: 32px;          /* 오른쪽 여백 */
      width: calc(100% - 152px);   /* 전체 - (120 + 32) */
      box-sizing: border-box;
      word-break: keep-all;
      overflow-wrap: anywhere;
    }
    .para { display: flex; flex-direction: column; gap: 10px; }
    .sent { display: inline; }

    /* 토큰 공통(도형 항상 표시) */
    .token {
      --pad: 8px;
      position: relative;
      display: inline-block;
      padding: var(--pad) 12px;
      outline: none;
    }
    .token .label { position: relative; z-index: 1; }
    .token .shape {
      position: absolute; inset: 0; width: 100%; height: 100%;
      z-index: 0; pointer-events: none; fill: none; stroke-width: 2px; display: block; /* 항상 표시 */
    }

    /* 색상 */
    .subject .shape { stroke: #f97316; }
    .object  .shape { stroke: #22c55e; }
    .verb    .shape { stroke: #3b82f6; }
    .verb rect { rx: 6; ry: 6; }

    /* 일반 텍스트 */
    .plain { display: inline; padding: 0 0.1em; }

    /* ── 모바일 최적화 ───────────────────────────────────────── */
    @media (max-width: 768px) {
      body { padding: 16px; }

      #output {
        margin: 0;
        width: 100%;
        font-size: 1rem;
        padding: 14px;
      }
      .token { --pad: 6px; padding: var(--pad) 10px; }
    }
  </style>
</head>
<body>
  <h1>Studysync</h1>

  <!-- 버튼 영역 삭제 -->
  <div class="controls"></div>

  <div id="output"></div>

  <script>
    // 단일 지문 (경제 지문)
    const passage = [
      { parts: [
        { role: 'sub', text: '시장경제에서' },
        { role: 'sub', text: '가격은' },
        { role: 'obj', text: '자원 배분의 핵심 기능을' },
        { role: 'verb', text: '수행한다' },
        { role: 'text', text: '.' }
      ]},
      { parts: [
        { role: 'sub', text: '수요와 공급의 원리는' },
        { role: 'obj', text: '시장 가격의 결정 과정을' },
        { role: 'verb', text: '설명한다' },
        { role: 'text', text: '.' }
      ]},
      { parts: [
        { role: 'text', text: '일반적으로' },
        { role: 'sub', text: '수요가' },
        { role: 'verb', text: '증가하면' },
        { role: 'sub', text: '가격은' },
        { role: 'verb', text: '상승하고' },
        { role: 'text', text: ',' },
        { role: 'sub', text: '공급이' },
        { role: 'verb', text: '증가하면' },
        { role: 'sub', text: '가격은' },
        { role: 'verb', text: '하락한다' },
        { role: 'text', text: '.' }
      ]},
      { parts: [
        { role: 'text', text: '이러한' },
        { role: 'sub', text: '가격 메커니즘은' },
        { role: 'obj', text: '시장의 효율성을' },
        { role: 'verb', text: '보장하는' },
        { role: 'obj', text: '중요한 역할을' },
        { role: 'verb', text: '담당한다' },
        { role: 'text', text: '.' }
      ]},
      { parts: [
        { role: 'text', text: '그러나' },
        { role: 'sub', text: '시장 실패가' },
        { role: 'verb', text: '발생하면' },
        { role: 'sub', text: '정부의 개입이' },
        { role: 'verb', text: '필요하다' },
        { role: 'text', text: '.' }
      ]},
      { parts: [
        { role: 'sub', text: '외부효과나' },
        { role: 'sub', text: '공공재의 존재는' },
        { role: 'obj', text: '시장 실패의 대표적 사례를' },
        { role: 'verb', text: '보여준다' },
        { role: 'text', text: '.' }
      ]}
    ];

    const out = document.getElementById("output");

    // 도형 토큰 생성 (툴팁 제거)
    function createShapedToken(kind, text) {
      const token = document.createElement("span");
      token.className = `token ${kind}`;
      token.tabIndex = -1;

      const label = document.createElement("span");
      label.className = "label";
      label.textContent = text;
      token.appendChild(label);

      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.classList.add("shape");
      token.appendChild(svg);

      requestAnimationFrame(() => {
        const pad = parseFloat(getComputedStyle(token).getPropertyValue('--pad')) || 8;
        const w = label.offsetWidth + pad * 2;
        const h = label.offsetHeight + pad * 2;
        svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
        svg.setAttribute("width", w);
        svg.setAttribute("height", h);
        svg.innerHTML = "";

        if (kind === "subject") {
          const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
          poly.setAttribute("points", `${w/2},0 0,${h} ${w},${h}`);
          svg.appendChild(poly);
        } else if (kind === "object") {
          const e = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
          e.setAttribute("cx", w/2); e.setAttribute("cy", h/2);
          e.setAttribute("rx", Math.max(6, w/2 - 2)); e.setAttribute("ry", Math.max(6, h/2 - 2));
          svg.appendChild(e);
        } else if (kind === "verb") {
          const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          r.setAttribute("x", 1); r.setAttribute("y", 1);
          r.setAttribute("width", Math.max(2, w - 2)); r.setAttribute("height", Math.max(2, h - 2));
          r.setAttribute("rx", 6); r.setAttribute("ry", 6);
          svg.appendChild(r);
        }
      });

      return token;
    }

    function renderPart({ role, text }) {
      if (role === 'sub' || role === 'obj' || role === 'verb') {
        const cls = role === 'sub' ? 'subject' : role === 'obj' ? 'object' : 'verb';
        return createShapedToken(cls, text);
      }
      const span = document.createElement('span');
      span.className = 'plain';
      span.textContent = text;
      return span;
    }

    function renderPassage() {
      out.textContent = "";
      const para = document.createElement("div");
      para.className = "para";

      passage.forEach(sentence => {
        const line = document.createElement("div");
        line.className = "sent";

        sentence.parts.forEach(part => {
          line.appendChild(renderPart(part));
          if (part.role !== 'text' || !/[.,!?]/.test(part.text)) {
            line.appendChild(document.createTextNode(' '));
          }
        });

        para.appendChild(line);
      });

      out.appendChild(para);
    }

    // 초기 렌더: 도형이 항상 보이도록
    renderPassage();
  </script>
</body>
</html>
